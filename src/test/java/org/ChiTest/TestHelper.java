package org.ChiTest;import java.io.ByteArrayOutputStream;import java.io.OutputStream;import java.io.UnsupportedEncodingException;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.math.BigInteger;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.security.PublicKey;import java.security.interfaces.RSAKey;import java.security.interfaces.RSAPublicKey;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.*;import static org.junit.Assert.*;public final class TestHelper {    private static final String NUMBERS = "1234567890";    private static final String UPPERCASES = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";    private static final String LOWERCASES = "abcdefghijklmnopqrstuvwxyz";    private static final String DASH_HYPHEN = "-_";    private static final String[] PROFANITY_WORDS = new String[] { "fuck", "tmd", "nnd", "18dy" };    /**     * --------------------------------------------------------------------------------------------------------------------------------------------**/    public String getDate(Date date) {        // 输出格式: 2015-1-27 00:00:00 大写H为24小时制        DateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");        return sdf.format(date);    }    public static String formatDate(Date date) {        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd");        return date == null ? null : formatter.format(date);    }    public static Date getDate(String date) throws ParseException {        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd");        return date == null ? null : formatter.parse(date);    }    /**     * 获取指定大小的 list     * @param size     * @param object     * @return     */    public static List getFixSizeList(int size,Object object){        List fixList = new ArrayList();        for (int i = 0; i < size; i++){            fixList.add(object);        }        return fixList;    }     /**      * --------------------------------------------------------------------------------------------------------------------------------------------**/    /**     * 设置指定的字段     * @param object  要修改的 DTO     * @param propertyName 要修改的字段名     * @param propertyValue 想要修改的值     * @return     * @throws IllegalAccessException     */    public static Object setClassField(Object object, String propertyName, Object propertyValue) throws IllegalAccessException {        Field field = getClassField(object.getClass(), propertyName);        assertNotNull("无法设置字段"+propertyName +"的值",field);        field.setAccessible(true);        field.set(object, propertyValue);        return object;    }    public static Object setClassFields(Object object, Map<String, Object> m) throws IllegalAccessException {        for(Map.Entry<String, Object> entry:m.entrySet()){            Field field = getClassField(object.getClass(), entry.getKey());            assertNotNull("无法设置字段"+ entry.getKey() +"的值",field);            field.setAccessible(true);            field.set(object, entry.getValue());        }        return object;    }    /**     * 获取类指定的字段     * @param aClazz     * @param aFieldName     * @return     */    public static Field getClassField(Class aClazz, String aFieldName )  {        Field[] declaredFields = aClazz.getDeclaredFields();        for (Field field : declaredFields) {            if (field.getName().equals(aFieldName)) {                return field;            }        }        //getDeclaredFields() 方法只能获得本类的属性值,所以要简单的递归一下        Class superclass = aClazz.getSuperclass();        if (superclass != null) {            return getClassField(superclass, aFieldName);        }        return null;    }    public static void getAllClassField(Class aClazz, Map fieldMap  )  {        Field[] declaredFields = aClazz.getDeclaredFields();        for (Field field : declaredFields){            fieldMap.put(field.getName(),field);        }        Class superclass = aClazz.getSuperclass();        if (superclass != null) {            getAllClassField(superclass, fieldMap);        }    }    /*    getDeclaredMethods()    返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。    getMethods()    返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。    */    /**     *根据特殊值找字段     * @param specifiedField     * @param specifiedValue     * @param actualObjects     * @return     * @throws NoSuchMethodException     * @throws InvocationTargetException     * @throws IllegalAccessException     */    /**     * 对于列表的测试, 需要先对比 是否有多余的标识值(主键值),如 resCode, 再拿列表中的一个元素 全字段校验     * @param specifiedField     * @param specifiedValue     * @param actualObjects     * @return     * @throws NoSuchMethodException     * @throws InvocationTargetException     * @throws IllegalAccessException     */    public static Object searchSpecifiedObjectInList(String specifiedField, Object specifiedValue, List actualObjects) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {        for (Object actualObject : actualObjects) {            if(String.valueOf(                    actualObject.getClass().getMethod("get" + firstWordUppercase(specifiedField)).invoke(actualObject)            ).equals(                    String.valueOf(specifiedValue)            )){                return actualObject;            }        }        return null;    }    public static List searchSpecifiedObjectListInList(String specifiedField, Object specifiedValue, List actualObjects) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {        List specifiedObjects = new ArrayList();        for (Object actualObject : actualObjects) {            if(String.valueOf(                    actualObject.getClass().getMethod("get" + firstWordUppercase(specifiedField)).invoke(actualObject)            ).equals(                    String.valueOf( specifiedValue)            )){                specifiedObjects.add(actualObject) ;            }        }        return specifiedObjects;    }    public static int countSpecifiedObjectsInList(Map<String, List> m, List actualObjects) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {        int count = 0;        for(Map.Entry<String, List> entry:m.entrySet()){            for (Object object: entry.getValue()) {                count += searchSpecifiedObjectListInList(entry.getKey(),  object,  actualObjects).size();            }        }        return count;    }    public static Set getDistinctValuesOfObjectInALists(String specifiedField, List actualObjects  ) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {        Set set = new HashSet();        for (Object actualObject : actualObjects) {            set.add(                    actualObject.getClass().getMethod("get" + firstWordUppercase(specifiedField)).invoke(actualObject)            );        }        return set;    }    public static void assertDistinctValueInAList( String specifiedField, List expectValues, List actualObjects) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {        Set set = getDistinctValuesOfObjectInALists( specifiedField,  actualObjects  );        assertEquals("列表中某字段的值与预期数量不一致" + set.toArray(), expectValues.size(), set.size());        for (Object objcet: expectValues             ) {            assertTrue("预期中有值是列表中所没有的" + objcet, set.contains(objcet) );        }    }    public static void assertSpecialObjectsExistInList(List<String> specifiedFields, Object[][] specifiedValues, List actualObjects) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {        for (int i = 0; i < specifiedValues.length ; i++) {            assertNotNull("没有发现存在的对象 查询字 字段值 " + specifiedValues[i][0],                    searchSpecialObjectInListByFields( specifiedFields, specifiedValues[i], actualObjects));        }    }    public static void assertSpecialObjectExistInList(String specifiedField, Object specifiedValue, List actualObjects) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {        assertNotNull("没有发现存在的对象 查询字段名 "+ specifiedField + " 字段值 " + specifiedValue,                searchSpecifiedObjectInList( specifiedField, specifiedValue, actualObjects));    }    public static void assertSpecialObjectsExistInList(String specifiedField, List specifiedValues, List actualObjects) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {        for (Object object : specifiedValues) {            assertNotNull("没有发现存在的对象 查询字段名 "+ specifiedField + " 字段值 " + object,                    searchSpecifiedObjectInList( specifiedField, object, actualObjects));        }    }    public static void assertSpecialObjectNotExistInList(String specifiedField, Object specifiedValue, List actualObjects) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {        assertNull("发现存在的对象 查询字段名 "+ specifiedField + " 字段值 " + specifiedValue,                searchSpecifiedObjectInList( specifiedField, specifiedValue, actualObjects));    }    public static void assertSpecialObjectsNotExistInList(String specifiedField, List<Object> specifiedValues, List actualObjects) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {        for (Object object : specifiedValues) {            assertNull("发现存在的对象 查询字段名 "+ specifiedField + " 字段值 " + object,                    searchSpecifiedObjectInList( specifiedField, object, actualObjects));        }    }/*    public static boolean doseSpecialObjectExistInList(String specifiedField, Object specifiedValue, List actualObjects) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {        Boolean isFound = false;        for (Object actualObject : actualObjects) {            if(String.valueOf(                    actualObject.getClass().getMethod("get" + firstWordUppercase(specifiedField)).invoke(actualObject)            ).equals(                    String.valueOf(specifiedValue))){                isFound = true;            }        }        return isFound;    }*/    public static Object searchSpecialObjectInListByFields(List<String> specifiedFields, Object[] specifiedValues, List actualObjects) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {        Boolean isFound = true;        for (Object object: actualObjects) {            for (int i = 0; i < specifiedFields.size(); i++) {                if(!String.valueOf(                        object.getClass().getMethod("get" + firstWordUppercase(specifiedFields.get(i))).invoke(object)                ).equals(                        String.valueOf(specifiedValues[i] )                )){                    isFound = false;                    break;                }            }            if (isFound){                return object;            }else {                isFound = true;            }        }        return null;    }    public static void assertSpecialObjectFieldInList(String specifiedField, List<String> specifiedValues, List actualObjects) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {        for (int i = 0; i < specifiedValues.size() ; i++) {            assertEquals("指定字段值不对: " + specifiedValues.get(i) ,specifiedValues.get(i),String.valueOf(                    actualObjects.get(i).getClass().getMethod("get" + firstWordUppercase(specifiedField)).invoke( actualObjects.get(i)  )));        }    }    /**     * 根据某个字段的某个值,选出列表中的对象进行比较     * @param specifiedField     * @param specifiedValue     * @param expectObject     * @param actualObjects     * @param excludeFieldNames     * @throws NoSuchMethodException     * @throws IllegalAccessException     * @throws InvocationTargetException     */    public static void assertSpecifiedObjectInList(String specifiedField, String specifiedValue,Object expectObject, List actualObjects, String[] excludeFieldNames ) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {        Object actualObject = searchSpecifiedObjectInList(  specifiedField,  specifiedValue, actualObjects );        if ( actualObject != null){            assertPartResultData(expectObject,  actualObject, excludeFieldNames);        }else {            assertNull("没有找到指定的对象 " + specifiedField +" : "+ specifiedValue, "dd");        }    }    /**     * 比较两个列表 DTO     * @param expectObject     * @param actualObject     * @param excludeFieldNames     * @throws NoSuchMethodException     * @throws IllegalAccessException     * @throws InvocationTargetException     */    public static void assertPartResultData(List expectObject, List actualObject, String[] excludeFieldNames) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {        for (int i = 0; i < expectObject.size() ; i++) {            assertPartResultData(expectObject.get(i),actualObject.get(i),excludeFieldNames);        }    }    /**     * 指定某些字段不比较     * @param expectObject     * @param actualObject     * @param excludeFieldNames     * @throws NoSuchMethodException     * @throws IllegalAccessException     * @throws InvocationTargetException     */    public static void assertPartResultData(Object expectObject, Object actualObject, String[] excludeFieldNames) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {        List<String> assertFieldNames = new ArrayList<String>();        Map<String,Field> assertFields = new HashMap<String, Field>();        getAllClassField(expectObject.getClass(),assertFields );        if (excludeFieldNames != null) {            for (String excludeFieldName : excludeFieldNames) {                assertFields.remove(excludeFieldName);            }        }        for (String key : assertFields.keySet()) {            assertFieldNames.add(key);        }        assertResultData(expectObject,actualObject,assertFieldNames);    }    /**     * 验证两个 DTO  的全部字段     */    public static void assertAllResultData(Object expectObject, Object actualObject ) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {        assertPartResultData(expectObject,actualObject,null);    }        /**         * 验证某个 DTO 的某个字段         */    public static void assertResultField( Object expectVal, Object actualObject, String assertFieldName) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {        Class<?> actualCls = actualObject.getClass();        Object actualVal;        actualVal = actualCls.getMethod("get" + firstWordUppercase(assertFieldName)).invoke(actualObject);        if (expectVal == null && actualVal==null){            return;        }        assertEquals("对比的字段的类型不同 "+ assertFieldName, expectVal.getClass().getName(), actualVal.getClass().getName()  );        compareTwoList(assertFieldName, actualCls,expectVal,actualVal);        assertTwoField(assertFieldName, expectVal, actualVal);        //这个是校验那些不关注的字段的,只是我个人习惯用法, 可以去掉        System.out.println("compare " + assertFieldName);    }    /**     * 验证两个 DTO 的指定字段     *     */    public static void assertResultData( Object expectObject, Object actualObject, List<String> assertFieldNames) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {        Class<?> expectCls = expectObject.getClass();        Class<?> actualCls = actualObject.getClass();        Object expectVal;        Object actualVal;        for(String fieldName : assertFieldNames){            try {                expectVal = expectCls.getMethod("get" + firstWordUppercase(fieldName)).invoke(expectObject);                actualVal = actualCls.getMethod("get" + firstWordUppercase(fieldName)).invoke(actualObject);            }catch (NoSuchMethodException e){                System.out.println("field: "+ fieldName + "has no get method");                continue;            }            if (expectVal == null && actualVal==null){                continue;            }            //如果返回值是 list 则用另外一种方式判断            if(compareTwoList(fieldName, actualCls,expectVal,actualVal)){                continue;            }            assertTwoField(fieldName, expectVal, actualVal);            System.out.println("compare " + fieldName);        }    }    public static boolean compareTwoList(String fieldName, Class<?> actualCls, Object expectVal, Object actualVal) throws NoSuchMethodException {        if (actualCls.getMethod("get" + firstWordUppercase(fieldName)).getGenericReturnType().toString().contains("List") &&                !actualCls.getMethod("get" + firstWordUppercase(fieldName)).getGenericReturnType().toString().contains("Map")){            if(((List)expectVal).size() == 0 && ((List)actualVal).size() == 0) {                return true;            }            if(expectVal == null && actualVal == null) {                return true;            }            assertArrayEquals("对象包含的 list 不相同 field: " + fieldName, ((List) expectVal).toArray(), ((List) actualVal).toArray());            return true;        }        return false;    }    public static void assertTwoField(String fieldName,  Object expectVal, Object actualVal){        assertEquals("两个对象不完全一致,不一致的字段为 "+ fieldName,                String.valueOf(expectVal),                String.valueOf(actualVal));    }    public static void assertTwoMap(Map expectMap, Map actualMap){        for (Object key : expectMap.keySet()) {            assertEquals("map key= "+ key + " 的值与预期不一致 ", expectMap.get(key), actualMap.get(key) );        }    }    /*----------------------------------------------------------------------------------------------------------------*/    /**     * 发送 get请求     * @throws Exception     */    /*----------------------------------------------------------------------------------------------------------------*/    public static String firstWordUppercase(String string){        return string.substring(0,1).toUpperCase() + string.substring(1);    }    /**     * 获取时间戳     */    public static String getTimeMark(){        return (new Date()).getTime()+"";    }    public static String randomName() {        return filterProfanity(randomString(NUMBERS + UPPERCASES + LOWERCASES, 10, 30));    }    public static String randomContent() {        return filterProfanity(randomString(NUMBERS + UPPERCASES + LOWERCASES, 10, 100));    }    public static String randomProjectName() {        return filterProfanity(randomString(UPPERCASES + LOWERCASES, 1, 1)                + randomString(NUMBERS + UPPERCASES + LOWERCASES + DASH_HYPHEN, 2, 30));    }    public static String randomFileName() {        return filterProfanity(randomString(NUMBERS + UPPERCASES + LOWERCASES, 1, 1)                + randomString(NUMBERS + UPPERCASES + LOWERCASES + DASH_HYPHEN, 2, 30));    }    public static String randomNickname() {        return filterProfanity(randomString(NUMBERS + UPPERCASES + LOWERCASES + DASH_HYPHEN, 4, 16));    }    public static String randomPhone() {        return randomString(NUMBERS, 11, 11);    }    public static String randomURL() {        return "http://example.com/" + filterProfanity(randomString(NUMBERS + LOWERCASES, 1, 10));    }    public static <T> T randomIn(T[] group) {        int index = randomInteger(0, group.length - 1);        return group[index];    }    /**     * 从指定的字符集中的生成随机字符串     *      * @param charaterSet     *            字符集     * @param minLength     *            最小长度     * @param maxLength     *            最大长度     * @return     */    private static String randomString(String charaterSet, int minLength, int maxLength) {        int length = minLength + (int) (Math.random() * (maxLength - minLength + 1));        StringBuilder sb = new StringBuilder();        for (int i = 0; i < length; ++i) {            int pos = (int) (Math.random() * charaterSet.length());            sb.append(charaterSet.charAt(pos));        }        return sb.toString();    }    public static String getStringNumbers( int length) {        String sb = "";        for (int i = 0; i < length; ++i) {            sb += randomInteger(0,9);        }        return sb;    }    public static Integer getIntNumber( int length) {        return new Integer(getStringNumbers(length));    }    public  static String getFixLengthString(int length){        return getFixLengthString("ed",length);    }    public static String getFixLengthString( String fixString, int length ) {        if(fixString.length() == length){            return fixString;        }else if(fixString.length() < length){            StringBuilder sb = new StringBuilder();            sb.append(fixString);            for (int i=fixString.length(); i < length;i++ ){                int pos = (int) (Math.random() * fixString.length());                sb.append(fixString.charAt(pos));            }            return sb.toString();        }else {            return fixString.substring(0,length);        }    }    //获取随机字符    public static String getChineseWord() {        return "我";    }    public static String getMixCaseWord() {        return "AaZz";    }    public static String getMixCaseWord(String word) {        return word;    }    //过滤敏感字符    private static String filterProfanity(String string) {        for (int i = 0; i < PROFANITY_WORDS.length; ++i) {            int randomSize = PROFANITY_WORDS[i].length() - 1;            String replacement = "a" + randomString(NUMBERS, randomSize, randomSize);            string = string.replace(PROFANITY_WORDS[i], replacement);        }        return string;    }    /**     * 返回随机的布尔值     *      * @return     */    public static boolean randomBoolean() {        return ((int) (Math.random() * Integer.MAX_VALUE) % 2) == 1 ? true : false;    }    /**     * 返回<code>min</code>-<code>max</code>之间（包括<code>min</code>和<code>max</code> ）的随机整数。     *      * @param min     *            最小值     * @param max     *            最大值     * @return     */    public static int randomInteger(int min, int max) {        return min + (int) (Math.random() * (max - min + 1));    }    /**     * 返回给定路径的文件名部分     *      * @param path     *            路径     * @return     */    public static String getFileName(String path) {        int pos = path.lastIndexOf("/");        if (pos == -1) {            return path;        }        return path.substring(pos + 1);    }    /**     * 生成 SSH 公钥     *      * @return base64 编码的 SSH 公钥字符串     * @throws Exception     */    /*    public static String generateSSHPublicKey() throws Exception {        KeyPairGenerator generator;        generator = KeyPairGenerator.getInstance("RSA");        // or: generator = KeyPairGenerator.getInstance("DSA");        generator.initialize(2048);        KeyPair keyPair = generator.genKeyPair();        byte[] bytes = encodePublicKey(keyPair.getPublic());        Base64.Encoder encoder = Base64.getEncoder();        SimpleDateFormat formatter = new SimpleDateFormat("yyyyMMddHHmmss");        String dateStr = formatter.format(new Date());        return "ssh-rsa " + encoder.encodeToString(bytes) + " rsa-key-" + dateStr;    }*/    private static byte[] encodePublicKey(PublicKey key) throws Exception {        ByteArrayOutputStream out = new ByteArrayOutputStream();        /* encode the "ssh-rsa" string */        byte[] sshrsa = new byte[] { 0, 0, 0, 7, 's', 's', 'h', '-', 'r', 's', 'a' };        out.write(sshrsa);        /* Encode the public exponent */        BigInteger e = ((RSAPublicKey) key).getPublicExponent();        byte[] data = e.toByteArray();        encodeUInt32(data.length, out);        out.write(data);        /* Encode the modulus */        BigInteger m = ((RSAKey) key).getModulus();        data = m.toByteArray();        encodeUInt32(data.length, out);        out.write(data);        return out.toByteArray();    }    private static void encodeUInt32(int value, OutputStream out) throws Exception {        byte[] tmp = new byte[4];        tmp[0] = (byte) ((value >>> 24) & 0xff);        tmp[1] = (byte) ((value >>> 16) & 0xff);        tmp[2] = (byte) ((value >>> 8) & 0xff);        tmp[3] = (byte) (value & 0xff);        out.write(tmp);    }    /**     * 将字符串编码成 SHA1     *      * @param text     *            待编码的字符串     * @return SHA1 编码字符串     * @throws NoSuchAlgorithmException     * @throws UnsupportedEncodingException     */    public static String sha1(String text) {        text = text.trim();        MessageDigest md;        try {            md = MessageDigest.getInstance("SHA-1");            byte[] sha1hash = new byte[40];            md.update(text.getBytes("iso-8859-1"), 0, text.length());            sha1hash = md.digest();            return convertToHex(sha1hash);        } catch (Exception e) {            return null;        }    }    private static String convertToHex(byte[] data) {        StringBuffer buf = new StringBuffer();        for (int i = 0; i < data.length; i++) {            int halfbyte = (data[i] >>> 4) & 0x0F;            int two_halfs = 0;            do {                if ((0 <= halfbyte) && (halfbyte <= 9))                    buf.append((char) ('0' + halfbyte));                else                    buf.append((char) ('a' + (halfbyte - 10)));                halfbyte = data[i] & 0x0F;            } while (two_halfs++ < 1);        }        return buf.toString();    }}